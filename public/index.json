[{"content":" 本文目的是记录我从 Java 开发转 Golang 开发的学习经历，分享一下学习过程来帮助想要 Java 转 Golang 的朋友一起进步一起学习！\n0、安装配置 下载地址：https://golang.google.cn/dl/\n下载好了用go version来校验\n配置环境：GOPATH、Path\n配置好了用go env来校验\n1、Golang基础 优势： 并发编程优雅简单：Go语言原生支持协程（goroutine）和管道（channel），并提供了灵活而简单的并发编程机制。使用goroutine可以让我们非常方便地实现高并发、高性能的服务，同时也能有效避免线程安全问题。 零值机制：天生就有初始值，不用考虑空值情况。 内存管理自动化：Go语言的垃圾回收机制使得开发者可以不用关心内存的回收问题，极大地降低了程序出错的可能性和代码的复杂度。 语法简洁、易读易写：Go语言的语法简洁，没有像C++和Java那样繁琐的语法，特别是其强制规范化的代码风格更是方便了开发者对代码的理解和阅读。 静态类型系统：Go语言采用静态类型系统，可以在编译期检查出很多类型错误，避免了在运行时出现的错误。 良好的可移植性：Go语言的标准库支持多种操作系统和硬件平台，开发者可以轻松地将代码移植到不同的平台上。 开发效率高：Go语言的构建工具可以帮助开发者进行高效构建和测试。同时，Go语言的包管理工具go mod也是一个非常强大的工具，可以帮助开发者解决依赖管理和版本控制等问题。 命令 go build go build -o \u0026#34;***.exe\u0026#34; go run main.go go install 变量 package main import \u0026#34;fmt\u0026#34; // 匿名变量(就是一个下划线) -\u0026gt; _ : 匿名变量不占用命名空间，不会分配内存（Lua里叫哑元变量） func foo(i int, s string) (int, string) { return i, s } func main() { x, _ := foo(0, \u0026#34;zero\u0026#34;) _, y := foo(1, \u0026#34;one\u0026#34;) fmt.Println(x, y) var name string // 声明 var age int = 16 // 声明并赋值 // 类型推导 var s1 string = \u0026#34;string1\u0026#34; var s2 = \u0026#34;string2\u0026#34; // 上面可直接写成这样 // 简短变量声明，只能在函数中使用，不能在全局使用 s3 := \u0026#34;string3\u0026#34; // 上面的简写 fmt.Println(name, age, s1, s2, s3) } 注意事项：\n函数外每个语句必须以关键字开始（var、func、const等） := 不能用于函数外 _用于占位符，表示忽略值 函数内声明变量不使用，编译不能通过（似乎不同版本有不同的要求） 常量 常量是恒定不变的值，使用关键字const\npackage main // 单个声明 const pai = 3.1415926 // 批量声明 const ( statusOK = 200 notFound = 404 ) // 这种批量声明方式，没有赋值的常量默认和上面那个值一样 const ( n1 = 200 n2 n3 ) // iota: 常量计数器, iota将在const关键字出现时重置为0，const中每新增一行常量声明将使iota计数一次（iota可以理解成const语句块的行索引）。使用iota简化定义，在定义枚举时很有用 const ( n1 = iota // 0 n2 // 1 n3 // 2 n4 // 3 ) const ( a1 = iota // 0 a2 // 1 _ // 2 a3 // 3 ) const ( b1 = iota // 0 b2 = 100 // 100 b3 = iota // 2 b4 // 3 ) // 多个常量声明在一行 const ( c1, c2 = iota + 1, iota + 2 // d1:0+1, d2:0+2 c3, c4 = iota + 1, iota + 2 // d3:1+1, d4:1+2 ) // iota的应用，举个例子 const ( _ = iota KB = 1 \u0026lt;\u0026lt; (10 * iota) MB = 1 \u0026lt;\u0026lt; (10 * iota) GB = 1 \u0026lt;\u0026lt; (10 * iota) TB = 1 \u0026lt;\u0026lt; (10 * iota) PB = 1 \u0026lt;\u0026lt; (10 * iota) ) 基本数据类型 基本数据类型有整型、浮点型、布尔型、字符串、数组、切片、结构体、函数、map、通道等\n整型 int8、int16、int32、int64、uint8、uint16、uint32、uint64\n特殊整型：\n类型 描述 uinit 32位操作系统上就是uint32，64位操作系统上就是uint64 int 32位操作系统上就是int32，64位操作系统上就是int64 uintptr 无符号整型，用于存放一个指针 八进制\u0026amp;十六进制 Go语言中无法直接使用二进制，关于八进制和十六进制实例如下：\npackage main import \u0026#34;fmt\u0026#34; func main() { var num1 = 101 // 十进制 fmt.Printf(\u0026#34;%d\\n\u0026#34;, num1) // 输出十进制数 fmt.Printf(\u0026#34;%b\\n\u0026#34;, num1) // 输出二进制数 fmt.Printf(\u0026#34;%o\\n\u0026#34;, num1) // 输出八进制数 fmt.Printf(\u0026#34;%x\\n\u0026#34;, num1) // 输出十六进制数 fmt.Printf(\u0026#34;%T\\n\u0026#34;, num1) // 输出数据类型 var num2 = 077 // 八进制 var num3 = 0x123456789abcdef // 十六进制 // 强制声明int8类型 var num4 int8 = 100 fmt.Println(num2, num3, num4) } 浮点型 float32、float64\npackage main import \u0026#34;fmt\u0026#34; func main() { f1 := 1.2345 fmt.Printf(\u0026#34;%T\\n\u0026#34;, f1) // float64 默认go语言中小数都是float64 } 复数 complex128和complex64\n布尔型 Go语言中使用bool类型声明布尔型，只有true和false两个值\n注意事项：\n布尔型默认值是false 不允许将整型强转为布尔型 布尔型无法参与数值运算，也无法与其他类型进行转换 字符串 Go语言中字符串内部实现使用UTF-8编码，字符串的值为双引号的内容。\nGo语言单引号包裹的是字符。\npackage main import \u0026#34;fmt\u0026#34; func main() { s1 := \u0026#34;嘻嘻\u0026#34; s2 := \u0026#39;1\u0026#39; s3 := \u0026#39;a\u0026#39; s4 := \u0026#39;岳\u0026#39; // 字节：1字节 = 8Bit（8个二进制位） // 定义多行字符串，使用`` s5 := `床前明月光 疑是地上霜 举头望明月 低头思故乡 ` fmt.Print(s1, s2, s3, s4, s5) } 字符串操作 功能 方法 求长度 len（str） 拼接字符串 加号或者fmt.Sprintf() 分割 strings.Split 是否包含 strings.contains 前后缀判断 strings.HasPrefix/strings.HasSuffix 子串出现的位置 strings.Index()/strings.LastIndex() join操作 strings.Join(a []string, sep string) 字符 组成字符串的元素称为字符，Go语言字符有两种：\nuint8，或者叫byte类型，代表了ASCII码的一个字符 rune，代表一个UTF-8字符，当需要表示中文、日语或者其他复合字符时，就需要用到rune类型。rune类型实际上是一个int32 修改字符串 字符串是无法直接修改的，如果修改，可以转换成字符切片\npackage main import \u0026#34;fmt\u0026#34; func main() { s1 := \u0026#34;岳小杨超可爱\u0026#34; s2 := []rune(s1) s2[2] = \u0026#39;羊\u0026#39; fmt.Printf(string(s2)) // 将s2强制转换成string } 复合数据类型 数组 数组的长度是数组类型的一部分\npackage main import \u0026#34;fmt\u0026#34; func main() { var nums [3]int fmt.Println(nums) } 初始化 如果不初始化，默认元素为零值\npackage main import \u0026#34;fmt\u0026#34; func main() { // 方式一 var nums1 = [4]int{1, 2, 3, 4} // [1, 2, 3, 4] // 方式二 var nums2 = [...]int{1, 2, 3, 4} // [1, 2, 3, 4] // 方式三 var nums3 = [4]int{1, 2} // [1, 2, 0, 0] // 方式四 var nums4 = [4]int{0: 1, 3: 4} // [1, 0, 0, 4] fmt.Println(nums1, nums2, nums3, nums4) } 遍历 package main import \u0026#34;fmt\u0026#34; func main() { names := [...]string{\u0026#34;岳杨\u0026#34;, \u0026#34;幂律\u0026#34;, \u0026#34;GO语言\u0026#34;} // 方式一 for i := 0; i \u0026lt; len(names); i++ { fmt.Println(names[i]) } // 方式二 for i, v := range names { fmt.Println(i, v) } } 数组是值类型\npackage main import \u0026#34;fmt\u0026#34; func main() { // 证明数组是值类型 nums1 := [3]int{1, 2, 3} nums2 := nums1 nums2[0] = 100 fmt.Println(nums1, nums2) // [1, 2, 3] [100, 2, 3] } 切片 切片Slice是一个拥有相通类型元素的可变长度的序列\npackage main import \u0026#34;fmt\u0026#34; func main() { var nums1 []int var nums2 []int fmt.Println(nums1 == nil) // true fmt.Println(nums2 == nil) // true nums1 = []int{1, 2, 3} nums2 = []int{4, 5, 6, 7} fmt.Println(nums1 == nil) // false fmt.Println(nums2 == nil) // false } 长度和容量 package main import \u0026#34;fmt\u0026#34; func main() { nums1 := []int{1, 3, 5, 7} // 切片 nums2 := [7]int{0, 1, 2, 3, 4, 5, 6} // 数组 fmt.Printf(\u0026#34;%d %d\\n\u0026#34;, len(nums1), cap(nums1)) fmt.Printf(\u0026#34;%d %d\\n\u0026#34;, len(nums2), cap(nums2)) } 由数组得到切片 package main import \u0026#34;fmt\u0026#34; func main() { nums1 := [7]int{0, 1, 2, 3, 4, 5, 6} // 数组 nums2 := nums1[0:4] // [0, 1, 2, 3] // 数组得到切片，左闭右开 nums3 := nums1[1:] nums4 := nums1[:4] nums5 := nums1[:] fmt.Println(nums1, nums2, nums3, nums4, nums5) } 1、切片是引用类型，真正的数组都是保存在底层的数组里。\n2、一个nil的切片是没有底层数组的。\n3、判断切片为空应该判断len() == 0。\n4、nil的切片就算没有底层数组，也可以进行append操作，append会自动为nil切片创建空间。\nmake函数 package main import \u0026#34;fmt\u0026#34; func main() { nums1 := make([]int, 5, 10) // 参数：切片类型，长度，容量 fmt.Println(nums1) } append函数 package main import \u0026#34;fmt\u0026#34; func main() { nums1 := []int{1, 2, 3} nums1[3] = 4 // 错误写法，切片超过容量导致编译错误：索引越界 fmt.Println(nums1) // append函数 fmt.Printf(\u0026#34;%v %d %d\u0026#34;, nums1, len(nums1), cap(nums1)) // [1, 2, 3] len=3 cap=3 nums1 = append(nums1, 4) // 调用append函数必须用原来的切片变量接收返回值 fmt.Printf(\u0026#34;%v %d %d\u0026#34;, nums1, len(nums1), cap(nums1)) // [1, 2, 3, 4] len=4 cap=6 } 调用append函数必须用原来的切片变量接收返回值，底层涉及到数组的重新分配内存空间\nappend函数会为空切片创建内存空间，并且会对容量不够的切片进行扩容操作\nfmt包 package main import \u0026#34;fmt\u0026#34; func main() { var num = 100 fmt.Printf(\u0026#34;%T\\n\u0026#34;, num) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num) fmt.Printf(\u0026#34;%b\\n\u0026#34;, num) fmt.Printf(\u0026#34;%d\\n\u0026#34;, num) fmt.Printf(\u0026#34;%o\\n\u0026#34;, num) fmt.Printf(\u0026#34;%x\\n\u0026#34;, num) var str = \u0026#34;String\u0026#34; fmt.Printf(\u0026#34;%s\\n\u0026#34;, str) fmt.Printf(\u0026#34;%v\\n\u0026#34;, num) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, num) } 流程控制 if package main import \u0026#34;fmt\u0026#34; func main() { expression := true // 经典用法 if expression { // 执行操作 } else { // 执行操作 } // 特殊用法 if age := 19; age \u0026gt; 18 { fmt.Printf(\u0026#34;青年\u0026#34;) } } for package main import \u0026#34;fmt\u0026#34; func main() { for i := 0; i \u0026lt; 10; i++ { // 执行操作 fmt.Println(i) if i \u0026lt; 3 { continue // 跳过for循环 } else if i \u0026lt; 6 { break // 跳出for循环 } goto breakLabel // 跳出到标签 } breakLabel: // 标签 fmt.Println(\u0026#34;跳出来了，嘻嘻\u0026#34;) } for range package main import \u0026#34;fmt\u0026#34; func main() { s := \u0026#34;yueyang\u0026#34; for i, c := range s { fmt.Printf(\u0026#34;%d, %c\\n\u0026#34;, i, c) } } switch package main func main() { str := \u0026#34;0\u0026#34; switch str { case \u0026#34;0\u0026#34;: // 操作 case \u0026#34;1\u0026#34;: // 操作 default: // 操作 } switch str = \u0026#34;1\u0026#34;; str { case \u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;: // 操作 fallthrough // 向下穿透一个 case \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;: // 操作 default: // 操作 } } 运算符 \u0026amp;按位与\n|按位或\n^按位异或\n\u0026lt;\u0026lt;左移\n\u0026gt;\u0026gt;右移\n指针 取地址操作符\u0026amp;\n取值操作符*\n注意事项：\n引用类型变量不仅要声明还要分配内存空间 那么就引入了两个初始化方式new make\nnew函数 new函数不太常用\npackage main type T struct{} func new(T) *T // 接收一个类型，返回该类型的指针 make函数 make也是用于内存分配的，区别于new，make函数只作用于slice、map、chan类型的内存创建，由于这些类型本身就是引用类型，make返回的就是类型本身。\npackage main func make(t string, size ...int) string // 接收一个类型和容量大小，返回类型本身 make函数是不可替代的函数，slice、map、chan都需要make函数初始化才能进行操作。\nnew和make 两者都是用来创建内存的 new用于类型的内存分配，内存对应的值为类型的零值，返回的是指向类型的指针 make作用于slice、map、chan类型，返回类型本身 结构体 自定义类型 类型定义和类型别名\npackage main import \u0026#34;fmt\u0026#34; // NewInt 类型定义 type NewInt int // MyInt 类型别名 type MyInt = int func main() { var a NewInt var b MyInt fmt.Println(\u0026#34;%T\u0026#34;, a) // main.NewInt fmt.Println(\u0026#34;%T\u0026#34;, b) // int } 结构体 Go语言通过struct来面向对象\npackage main type T struct { Id int Name string } 结构体实例化 package main import \u0026#34;fmt\u0026#34; type Person struct { name string age int8 } func main() { var person Person person.name = \u0026#34;yueyang\u0026#34; person.age = 24 fmt.Printf(\u0026#34;%v\\n\u0026#34;, person) // {yueyang, 24} fmt.Printf(\u0026#34;%#v\\n\u0026#34;, person) // main.Person{name:\u0026#34;yueyang\u0026#34;, age:24} } 匿名结构体 package main import \u0026#34;fmt\u0026#34; func main() { var user struct { Name string Age int } user.Name = \u0026#34;yueyang\u0026#34; user.Age = 24 fmt.Printf(\u0026#34;%#v\\n\u0026#34;, user) // struct { Name string; Age int }{Name:\u0026#34;yueyang\u0026#34;, Age:24} } 结构体指针 package main import \u0026#34;fmt\u0026#34; type Person struct{} func main() { var person = new(Person) fmt.Printf(\u0026#34;%+v\u0026#34;, *person) } 2、Golang标准库 strconv Atoi() 将字符串转换成整形\nItoa() 将整形转换成字符串\nParseBool() 解析字符串成布尔类型, 可以接受1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False; 否则返回错误\nParseInt() ParseUnit() 类似于ParseInt(), 区别在于不能接受正负号, 返回uint\nParseFloat() FormatBool() FormatInt() FormatUint() FormatFloat() 3、异常机制 go中追求简洁优雅，使用多返回值来返回错误解决异常情况。只有在除数为零时，才会真正的使用异常机制，defer、panic、recover\n底层实现看这篇文章\n调用 defer 关键字会立刻对函数中引用的外部参数进行拷贝\n4、Golang第三方包 github.com/gin-gonic/gin gin包提供golang一个基本web框架\ngin.Context实现了Golang标准库中的net/http下Handler接口中的唯一方法ServeHttp(ReponseWriter, *Request)\npackage http // A Handler responds to an HTTP request. // // ServeHTTP should write reply headers and data to the ResponseWriter // and then return. Returning signals that the request is finished; it // is not valid to use the ResponseWriter or read from the // Request.Body after or concurrently with the completion of the // ServeHTTP call. // // Depending on the HTTP client software, HTTP protocol version, and // any intermediaries between the client and the Go server, it may not // be possible to read from the Request.Body after writing to the // ResponseWriter. Cautious handlers should read the Request.Body // first, and then reply. // // Except for reading the body, handlers should not modify the // provided Request. // // If ServeHTTP panics, the server (the caller of ServeHTTP) assumes // that the effect of the panic was isolated to the active request. // It recovers the panic, logs a stack trace to the server error log, // and either closes the network connection or sends an HTTP/2 // RST_STREAM, depending on the HTTP protocol. To abort a handler so // the client sees an interrupted response but the server doesn\u0026#39;t log // an error, panic with the value ErrAbortHandler. type Handler interface { ServeHTTP(ResponseWriter, *Request) } type ResponseWriter struct { // ... } type Request struct { // ... } 这是 Golang 实现 WebService 最基础的接口，通过实现其方法来\nGolang 的编译过程 词法和语法分析：编译器读入源代码文件，对代码进行分词和语法分析，生成语法树的数据结构。 AST 转换：编译器会对语法树进行一些处理和转换，例如检查类型、解析函数调用等，在此过程中还会对代码进行优化。 代码生成：将转换后的语法树转换成机器码或字节码，并将其打包成可执行文件或库文件。 链接：链接器将被引用的库文件链接到目标程序中，生成最终的可执行文件。在 Golang 中，链接过程是由 go 工具自动完成的，开发人员无需显式执行链接命令。 ","permalink":"http://localhost:1313/posts/learn4go/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本文目的是记录我从 Java 开发转 Golang 开发的学习经历，分享一下学习过程来帮助想要 Java 转 Golang 的朋友一起进步一起学习！\u003c/p\u003e\n\u003c/blockquote\u003e","title":"Learn4go"},{"content":" 日常使用Git操作，随笔整理持续更新\n基本操作 初始化仓库 git init -- 在当前目录下初始化一个git仓库, 如果是基本项目开发基本用不到这个命令 克隆代码 git colne \u0026lt;url\u0026gt; 添加工作区文件到暂存区 git add \u0026lt;fileName\u0026gt; -- 指定一个文件添加到暂存区 git add . -- 常用, 将当前目录下的所有改动的文件添加到暂存区 工作区：项目目录下除了.git文件夹以外的区域，简单来说就是你的项目文件区域\n查看工作状态 git status -- 查看当前工作区和暂存区的文件状态 提交暂存区文件到本地仓库 git commit -m \u0026#34;本次提交的描述内容\u0026#34; 版本回退 git reset [--soft | --mixed | --hard ] [HEAD]-- 将暂存区的文件取消暂存 --mixed为默认参数，重置暂存区的文件与上一次提交保持一致，工作区内容不变。可以理解成把工作区的文件和上次一提交的文件重新比对。效果上就像把暂存区的文件重新拿到工作区。\n--soft为回退到上一个版本。\n--hard为撤销工作区中所有未提交的内容，将暂存区和工作区都回到上一次版本，并删除之前的所有信息。就把这个参数理解成回到某个版本\u0026quot;最初的样子\u0026quot;。效果上就像时间回溯到了上一个版本提交之前，重新开发上一个版本一样。\n其实git reset操作用好了还是挺有用的，比如你当前项目改了一堆没用的地方，你都不想要了，就可以：\ngit reset --hard HEAR将当前工作区和暂存区恢复成当前版本\u0026quot;最初的样子\u0026quot;，本地代码瞬间全没了！妙~~~啊！(\\狗头)\n拉取代码 git pull 推送本地仓库到远程仓库 git push \u0026lt;远程主机名\u0026gt; \u0026lt;本地分支名\u0026gt;:\u0026lt;远程分支名\u0026gt; -- 最原始的命令 git push -- 常用, 将当前分支推送到远程绑定的对应分支 更新远端分支 git remote update origin -p 分支操作 查看本地所有分支 git branch -a -- 展示的列表中*符号说明当前代码处于哪个分支 有时候远端的分支刷新了，你本地获取分支列表发现，\u0026ldquo;啊哈，分支列表和远端对应不上！\u0026quot;。这时候不用慌，是因为这个列表是保存在本地的，并不是从远端实时获取的，你需要做的就是刷新这个保存在本地的列表与远端同步：\ngit remote update origin -p -- 用远端来更新本地仓库 创建分支 git branch \u0026lt;name\u0026gt; -- 从当前分支创建了名称为 dev 的分支 切换分支 git checkout \u0026lt;branchName\u0026gt; -- 切换到本地目标分支 git checkout -b \u0026lt;newBranchName\u0026gt; -- 从当前分支创建一个新分支并切换到新分支上 git checkout -b操作可以在任一分支的任何状态执行，执行成功之后，会将所有操作复制到新的分支上，并且会切换到新分支，如果新分支提交了修改，则原有分支的操作会撤销掉。\n合并某分支到当前分支 git merge \u0026lt;branchName\u0026gt; -- 合并目标分支到当前分支 删除本地分支 git branch -d \u0026lt;branchName\u0026gt; -- 删除本地的目标分支 重新定基操作 git rebase \u0026lt;branchName\u0026gt; -- 以本地目标分支为基准，合并代码 首先，说明一下rebase的作用：将目标分支的开发呈现一条直线，没有其他分支合并进来的节点，展示起来比较清晰。\n那么能来点实际吗？——彳亍\ngit rebase相关流程\ngit checkout -b [本地开发分支名] origin/[远程分支名] -- 以目标分支为基准创建新分支并关联远端分支 ....... -- 修改代码的操作 git add . -- 添加所有本次修改的文件添加到暂存区 git commit -m \u0026#34;注释内容\u0026#34; -- 提交代码，保存本地分支 git checkout [主分支] -- 切换分支，这个分支是目标基点的分支，简单来说，就是把现在的代码变成从\u0026#34;这个分支开始进行开发\u0026#34;的分支 git pull -- 拉取主分支代码，此时本地仓库主分支代码为最新代码，本地开发分支有所有修改的代码 git checkout [本地开发分支] // 切回本地开发分支，准备rebase git rebase [主分支] -i HEAD~2 // 将当前分支合并提交到目标分支 // rebase过程可能会出现冲突，解决冲突后继续rebase过程 git rebase [主分支] --continue // 继续rebase过程 git push // 推送远端 当然，如果你不愿意在提交代码的时候进行rebase操作，你可以将git commit暂存操作换乘git stash暂存，这将使你的rebase过程变的无比顺利\n常见问题 提交代码 当进行了一个阶段的开发工作之后，就会需要对代码进行提交操作，推送到远端分支，这部分工作当然可以交给IDE来完成，不过我更推荐使用命令的形式，来更多的理解git的工作原理\n流程：暂存代码-\u0026gt;提交到本地仓库-\u0026gt;推送到远端分支\n# 1. 暂存代码：所有变化提交到暂存区 git add . # 2. 提交到本地仓库，这步需要简介且明确的写出本次提交的所有内容 git commit -m \u0026#34;本次提交内容的注释说明\u0026#34; # 3. 推送到远端分支 git push \u0026lt;远程主机名\u0026gt; \u0026lt;本地分支名\u0026gt;:\u0026lt;远程分支名\u0026gt; # 如果你看过了前面的内容后，应该可以轻松地简化这行命令 解决冲突 如果你充分理解了分支操作的本质，就会对冲突的解决应对自如，这里还是给出拉取代码时出现代码冲突情况的解决办法：\n流程：暂存(压栈)-\u0026gt;拉取代码-\u0026gt;释放代码（弹栈）-\u0026gt;手动合并冲突代码\n# 如果本地代码与线上代码有冲突，git pull 是会报错，如下： # error: Your local changes to \u0026#39;-----\u0026#39; would be overwritten by merge. Aborting.Please, commit your changes or stash them before you can merge. # 那么接下来，将是你需要做的几步： # 1. 将本地代码暂存，将工作区代码恢复到上一个版本 git stash # 2. 拉取代码，将工作区代码更新为远端最新版本 git pull # 3. 释放代码，也就是弹栈，将之前暂存的代码取出 git stash pop # 4. 手动合并代码，如果使用ide工具进行，这项工作将变的更加容易 # 5. 查看代码状态，会展示你这次合并代码过程中又对哪些文件进行了修改 git status # 6. 之后就是继续进行开发工作，再对新代码进行add、commit操作啦~^v^ 将本地项目提交到远程仓库（远程仓库是空项目） # 1. 先进入项目文件夹 cd 当前项目的完整路径 # 2. 初始化这个目录变成git可以管理的仓库 git init # 3. 暂存并提交代码 git add . git commit -m \u0026#34;Init Project\u0026#34; # 4. 关联到远程库 git remote add origin \u0026lt;你的远程库地址\u0026gt; # 5. 获取远程库与本地同步合并（如果远程库不为空必须做这一步，否则后面的提交会失败） git pull origin master # 6. 把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。 git push -u origin master ","permalink":"http://localhost:1313/posts/learn4git/","summary":"\u003cblockquote\u003e\n\u003cp\u003e日常使用Git操作，随笔整理持续更新\u003c/p\u003e\n\u003c/blockquote\u003e","title":"Learn4git"}]